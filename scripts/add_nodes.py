import json
import argparse
import os
import re
import logging
import copy
from qwikidata.entity import WikidataItem, WikidataProperty # type: ignore
from qwikidata.linked_data_interface import get_entity_dict_from_api # type: ignore
from generate_templates import TemplateGenerator

parser = argparse.ArgumentParser()
logging.basicConfig(
    filename='node_additions.log',
    filemode='w',
    format='%(asctime)s,%(msecs)d %(name)s %(levelname)s %(message)s',
    datefmt='%H:%M:%S',
    level=logging.INFO)
logger = logging.getLogger(__name__)

parser.add_argument(
    '--qnodes',
    type=str,
    required=True,
    help='The location of the file containing qnodes to be added.'
)
parser.add_argument(
    '--qnode_type',
    type=str,
    required=True,
    help='To which overlay section should the qnodes be added? Entities, or events?'
)
parser.add_argument(
    '--xpo',
    type=str,
    required=False,
    help='The location of the XPO overlay file to be modified. If no filename is provided, it will be inferred.'
)
parser.add_argument(
    '--overwrite',
    action='store_true',
    help='Include this flag to replace current DWD nodes with nodes generated by this code.'
)
parser.add_argument(
    '--update_redirects',
    action='store_true',
    help='Include this flag to rename DWD nodes with deprecated QIDs in Wikidata. The DWD node will be renamed AND overwritten with information provided from the input file.'
)
parser.add_argument(
    '--log_level',
    type=str,
    required=False,
    help='Log level for the logger. Set to WARNING by default. One of DEBUG, INFO, WARNING, ERROR, or CRITICAL.'
)

def infer_filename():
    dir_path = os.path.abspath(os.path.join(os.path.dirname( __file__ ), '..'))

    # first, strict search
    for root, dirs, files in os.walk(dir_path):
        for file in files:
            pattern = 'xpo_v[0-9]\.[0-9]([a-z]?|(\.[0-9])?)\.json'
            if re.fullmatch(pattern=pattern, string=str(file)):
                return root + '/' + str(file)
    
    # if it couldn't be found with the above pattern, a simpler check
    for root, dirs, files in os.walk(dir_path):
        for file in files:
            if 'xpo' in str(file) and '.json' in str(file):
                return root + '/' + str(file)
    
    return ''

def get_irregular_pb_arguments(base_form, roleset_name, append_to_file):
    # Attempting to find roleset with baseform
    try:
        elements = propbank.rolesets(base_form)
    except:
        logger.error(f'Base form {base_form} for {roleset_name} was incorrect.')
        return ''
    
    for element in elements:
        if element.attrib['id'] == roleset_name:
            roleset = element
            if append_to_file:
                # keep track of all of them that i find
                file_with_irregulars = open('scripts/irregular_propbank_ids.txt', 'a')
                file_with_irregulars.write(f'\n{roleset_name}\t{base_form}')
                file_with_irregulars.close()
            return roleset
    
    # unsuccessful
    return ''

def get_arguments(pb_string):
    try:
        roleset = propbank.roleset(pb_string)
    except:
        # first, look through a file where i've been storing these irregulars:
        file_with_irregulars = open('scripts/irregular_propbank_ids.txt')
        base_form = ''
        append_to_file = False
        for line in file_with_irregulars.readlines():
            tokens = line.strip().split('\t')
            if tokens[0] == pb_string:
                base_form = tokens[1]
        file_with_irregulars.close()
        if base_form == '':
            append_to_file = True
            # ask the user (myself) to give the base form
            base_form = input(f'Try entering the base form for {pb_string}:')

        roleset = get_irregular_pb_arguments(base_form, pb_string, append_to_file)

        # something still went wrong:
        if roleset == '':
            logger.error(f'Frameset file for {pb_string} not found.')
            return []

    arguments = []
    
    for role in roleset.findall("roles/role"):
        argument = {}

        n = role.attrib['n'].upper()
        f = role.attrib['f'].lower()
        desc = role.attrib['descr'].lower().replace(' ', '_')
        desc = desc.replace(',', '')

        short_name = 'A' + n + '_' + f
        name = short_name + '_' + desc
        argument['short_name'] = short_name
        argument['name'] = name
        argument['constraints'] = []
        arguments.append(argument)

    return arguments

def get_pnode_constraints(
    pnode, 
    slot
):
    '''
    Returns a dict of constraints for a certain Pnode and its argument slot

    Parameters
    ----------
    pnode : string
        ie, 'P1234'. The Pnode to query.
    slot : string
        One of 'subject' or 'object'. The slot for which we are returning constraints.
    '''
    dict_to_query = get_entity_dict_from_api(pnode)
    constraints = []

    subject_type_constraint_qnode = 'Q21503250'
    value_type_constraint_qnode = 'Q21510865'

    qnode_to_search_for = subject_type_constraint_qnode if slot == 'subject' else value_type_constraint_qnode

    # check WD node for P2302 "property constraint"
    if 'P2302' in dict_to_query['claims']:
        # P2302 relation may have several Qnode values with further qualifiers
        # telling us the constraints
        for p2302_value in dict_to_query['claims']['P2302']:
            if p2302_value['mainsnak']['datavalue']['value']['id'] == qnode_to_search_for:
                # Found property dict with constraints, so add them to our list
                # Now we find all values in the qualifier P2308 "class"
                for p2308_value in p2302_value['qualifiers']['P2308']:
                    q = p2308_value['datavalue']['value']['id']
                    q_dict = get_entity_dict_from_api(q)
                    try:
                        label = q_dict['labels']['en']['value']
                    except:
                        available_languages = list(q_dict['labels'].keys())
                        logger.warning(f'{slot} constraint {q} for {pnode} has no English label, using label from language {available_languages[0]}')
                        label = q_dict['labels'][available_languages[0]]['value']
                    constraints.append({'name': label, 'wd_node': q})
                return constraints
    else:
        logger.info(f'Pnode {pnode} has no {slot} constraints from Wikidata')
        return constraints
    logger.info(f'Pnode {pnode} has no {slot} constraints from Wikidata')
    return constraints

def get_arguments_with_pnode_mapping(
    pb_string,
    pnode,
    subj_mapping, 
    obj_mapping, 
    mapping_type
):
    '''
    Given a Pnode/PropBank mapping and any related flags, produce the argument dictionary
    for the JSON.

    Parameters
    ----------
    pb_string : string
        String corresponding to a PropBank roleset, ie 'disembark.01'
    pnode : string
        ie, 'P1234'. The Pnode in the mapping, used to query WD for its constraints.
    subj_mapping : string
        Which PB argument should the subject of the Pnode be mapped to? ie 'A1'. Empty string for no mapping.
    obj_mapping : string
        Which PB argument should the object of the Pnode be mapped to? ie 'AM_loc'. Empty string for no mapping.
    mapping_type : string
        Any flag to add to the argument mapping. None for no flags.
    '''
    roleset = propbank.roleset(pb_string)

    arguments = [None, None]

    subject_found = False if subj_mapping else True
    object_found = False if obj_mapping else True
    
    for role in roleset.findall("roles/role"):
        argument = {}
        wd_slot = ''
        relation_arg_slot = ''

        n = role.attrib['n'].upper()
        f = role.attrib['f'].lower()
        desc = role.attrib['descr'].lower().replace(' ', '_')
        desc = desc.replace(',', '')

        short_name = 'A' + n + '_' + f
        pb_mapping = short_name + '_' + desc

        if not subject_found:
            if subj_mapping == 'A' + n or subj_mapping == short_name:
                wd_slot = 'subject'
                subject_found = True
                relation_arg_slot = 'A0'

                argument['name'] = relation_arg_slot
                argument['wd_slot'] = wd_slot
                argument['pb_mapping'] = pb_mapping
                if mapping_type:
                    argument['mapping_types'] = [mapping_type]
                else:
                    argument['mapping_types'] = []
                argument['constraints'] = get_pnode_constraints(pnode, 'subject')
                arguments[0] = argument
                continue
        if not object_found:
            if obj_mapping == 'A' + n or obj_mapping == short_name:
                wd_slot = 'object'
                object_found = True
                relation_arg_slot = 'A1'

                argument['name'] = relation_arg_slot
                argument['wd_slot'] = wd_slot
                argument['pb_mapping'] = pb_mapping
                if mapping_type:
                    argument['mapping_types'] = [mapping_type]
                else:
                    argument['mapping_types'] = []
                argument['constraints'] = get_pnode_constraints(pnode, 'object')
                arguments[1] = argument

    # If argument not one of the core roles
    if not subject_found and subj_mapping.startswith('AM'):
        argument = {}
        argument['name'] = 'A0'
        argument['wd_slot'] = 'subject'
        argument['pb_mapping'] = subj_mapping
        if mapping_type:
            argument['mapping_types'] = [mapping_type]
        else:
            argument['mapping_types'] = []
        argument['constraints'] = get_pnode_constraints(pnode, 'subject')
        arguments[0] = argument
    if not object_found and obj_mapping.startswith('AM'):
        argument = {}
        argument['name'] = 'A1'
        argument['wd_slot'] = 'object'
        argument['pb_mapping'] = obj_mapping
        if mapping_type:
            argument['mapping_types'] = [mapping_type]
        else:
            argument['mapping_types'] = []
        argument['constraints'] = get_pnode_constraints(pnode, 'object')
        arguments[1] = argument

    if None in arguments:
        arguments = [arg for arg in arguments if arg != None]

    return arguments

if __name__ == '__main__':

    args = parser.parse_args()

    if args.log_level:
        logger.setLevel(args.log_level)
    if not args.xpo:
        filename = infer_filename()
        logger.warning(f'Filename not provided, inferred as "{filename}"')
    else:
        filename = args.xpo
    if args.qnode_type not in ['entities', 'events', 'relations']:
        logger.error(f'Can only add Qnodes that are "entities", "events", or "relations"')
        quit()
    
    if args.qnode_type == 'events' or args.qnode_type == 'relations':
        from nltk.corpus import propbank # type: ignore

    if args.qnode_type == 'events':
        template_gen = TemplateGenerator()

    f = open(filename)
    xpo = json.load(f)
    f.close()
    
    f = open(args.qnodes)
    added = 0

    for line in f.readlines():
        tokens = line.split('\t')
        qnode_string = tokens[0].strip()
        pb_roleset = None
        curated_by = None
        parent_qnode_string = None
        overlay_parents = []
        if len(tokens) > 1:
            # TODO add this to the documentation
            if args.qnode_type == 'entities':
                parent_qnode_string = tokens[1].strip()
                parent_qdict = get_entity_dict_from_api(parent_qnode_string)
                parent_q = WikidataItem(parent_qdict)
                parent_id = parent_q.entity_id
                parent_name = parent_q.get_label().lower().replace(' ', '_')
                if parent_id == parent_qnode_string:
                    overlay_parents.append({'name': parent_name, 'wd_node': parent_id})
                else:
                    logger.warning(f'Overlay parent {parent_qnode_string} for child {qnode_string} is deprecated in Wikidata. Cannot add.')
                    continue
            elif args.qnode_type == 'events':
                pb_roleset = tokens[1].strip()
                curated_by = tokens[2].strip()
            else:
                pb_roleset = tokens[1].strip()
        try:
            qdict = get_entity_dict_from_api(qnode_string)
        except:
            logger.error(f'\t{args.qnode_type}\t{qnode_string}\tnot_found_by_api\tskip')
            continue
        if 'Q' in qnode_string:
            q = WikidataItem(qdict)
        else:
            q = WikidataProperty(qdict)
        # WD values
        id_ = q.entity_id # do not use because it may differ from DWD ID
        name = q.get_label().lower().replace(' ', '_')
        desc = q.get_description()

        # DWD-specific values
        additional_rolesets = []
        ldc_types = []
        similar_nodes = []
        related_qnodes = []
        template = None
        template_curation = None

        # Handle case in which we have a Wikidata redirect:
        if id_ != qnode_string:
            try_dwd_key = dwd_key = 'DWD_' + id_
            if try_dwd_key in xpo[args.qnode_type]:
                if not args.update_redirects:
                    logger.warning(f'\t{args.qnode_type}\t{qnode_string}\tWD_redirect\tskip')
                    continue
                else:
                    logger.warning(f'\t{args.qnode_type}\tDWD_{qnode_string}\tWD_redirect\trenamed_{try_dwd_key}')
                    # deprecated_nodes['DWD_' + qnode_string] = copy.deepcopy(xpo[args.qnode_type]['DWD_' + qnode_string])
                    # deprecated_nodes['DWD_' + qnode_string]['redirects_to'] = try_dwd_key
                    del xpo[args.qnode_type]['DWD_' + qnode_string]
                    dwd_key = try_dwd_key
        else:
            dwd_key = 'DWD_' + qnode_string

        # What to do if we already have the Qnode in the overlay:
        if dwd_key in xpo['events'] or dwd_key in xpo['entities'] or dwd_key in xpo['relations'] or dwd_key in xpo['temporal_relations']:
            
            # Find out where in the overlay the Qnode is located...
            for k in ['events', 'entities', 'relations', 'temporal_relations']:
                if dwd_key in xpo[k]:
                    where = k
                    break
            if where != args.qnode_type:
                logger.info(f'Node {dwd_key} already exists in {where}. It will not be added in {args.qnode_type}.')
                continue
            
            # Handle integration of new PB roleset into the existing DWD Node:
            logger.info(f'\t{where}\t{dwd_key}\talready_exists\thandle_roleset_addition')
            if 'additional_rolesets' in xpo[where][dwd_key].keys():
                additional_rolesets = xpo[where][dwd_key]['additional_rolesets']

            # Check if this node already has a mapping
            if 'pb_roleset' in xpo[where][dwd_key].keys() and pb_roleset != xpo[where][dwd_key]['pb_roleset']:
                # Don't allow the user to overwrite nodes that have LDC mappings
                if 'ldc_types' in xpo[where][dwd_key].keys() and len(xpo[where][dwd_key]['ldc_types']) > 0:
                    logger.info(f'\t{where}\t{dwd_key}\tLDC_mapping\tadd_additional_roleset')
                    if pb_roleset not in additional_rolesets:
                        additional_rolesets.append(pb_roleset)
                    continue

                # Don't overwrite primary PB roleset if curation status is 'xpo'
                if 'curated_by' in xpo[where][dwd_key].keys():
                    if xpo[where][dwd_key]['curated_by'] == 'xpo':
                        logger.info(f'\t{where}\t{dwd_key}\talready_curated_by_xpo\tadd_additional_roleset')
                        if pb_roleset not in additional_rolesets:
                            additional_rolesets.append(pb_roleset)
                        continue
                    elif xpo[where][dwd_key]['curated_by'] == 'xpo_partial':
                        if curated_by == 'xpo':
                            logger.info(f'{where}\t{dwd_key}\tnew_roleset_higher_curation_status\treplace_primary_roleset_and_keep_as_additional_roleset')
                            if xpo[where][dwd_key]['pb_roleset'] not in additional_rolesets:
                                additional_rolesets.append(xpo[where][dwd_key]['pb_roleset'])
                        else:
                            logger.info(f'{where}\t{dwd_key}\tnew_roleset_same_curation_status\tadd_additional_roleset')
                            if pb_roleset not in additional_rolesets:
                                additional_rolesets.append(pb_roleset)
                            continue
                    elif xpo[where][dwd_key]['curated_by'] == 'CMU':
                        logger.info(f'{where}\t{dwd_key}\tnew_roleset_higher_curation_status\treplace_primary_roleset')
                
                    # If applicable, keep old overlay parents, LDC mappings, & similar/related nodes:
                    if 'overlay_parents' in xpo[where][dwd_key].keys():
                        overlay_parents = xpo[where][dwd_key]['overlay_parents']
                    if 'ldc_types' in xpo[where][dwd_key].keys():
                        ldc_types = xpo[where][dwd_key]['ldc_types']
                    if 'similar_nodes' in xpo[where][dwd_key].keys():
                        similar_nodes = xpo[where][dwd_key]['similar_nodes']
                    if 'related_qnodes' in xpo[where][dwd_key].keys():
                        related_qnodes = xpo[where][dwd_key]['related_qnodes']
            else:
                logger.info(f'\t{where}\t{dwd_key}\talready_exists_same_mapping\tchange_curated_by')
                if args.qnode_type == 'events':
                    xpo[where][dwd_key]['curated_by'] = curated_by
                continue
        else:
            # log this addition
            logger.info(f'\t{args.qnode_type}\t{dwd_key}\tnew_node\tnode_added')
            added += 1

        arguments = None
        if where == 'entities':
            type_string = 'entity_type'
            curated_by = 'xpo' # TODO Eventually, should change this
        elif where == 'relations':
            type_string = 'relation_type'

            try:
                subject = tokens[2].strip()
            except:
                subject = ''
            try:
                object_ = tokens[3].strip()
            except:
                object_ = ''
            try:
                mapping_type = tokens[4].strip()
            except:
                mapping_type = None

            arguments = get_arguments_with_pnode_mapping(
                pb_string=pb_roleset,
                pnode=qnode_string,
                subj_mapping=subject,
                obj_mapping=object_,
                mapping_type=mapping_type
            )
            curated_by = 'xpo' # TODO Eventually, should change this
        else:
            type_string = 'event_type'
            arguments = get_arguments(pb_roleset)

        xpo[where][dwd_key] = {}
        xpo[where][dwd_key]['type'] = type_string
        xpo[where][dwd_key]['name'] = name
        xpo[where][dwd_key]['wd_node'] = qnode_string
        xpo[where][dwd_key]['wd_description'] = desc
        xpo[where][dwd_key]['overlay_parents'] = overlay_parents
        if pb_roleset:
            xpo[where][dwd_key]['pb_roleset'] = pb_roleset
            xpo[where][dwd_key]['additional_rolesets'] = additional_rolesets
        xpo[where][dwd_key]['curated_by'] = curated_by
        if arguments:
            xpo[where][dwd_key]['arguments'] = arguments
        xpo[where][dwd_key]['ldc_types'] = ldc_types
        xpo[where][dwd_key]['similar_nodes'] = similar_nodes
        if where == 'relations':
            xpo[where][dwd_key]['related_qnodes'] = related_qnodes
        if where == 'events':
            if template and template_curation:
                xpo[where][dwd_key]['template'] = template
                xpo[where][dwd_key]['template_curation'] = template_curation
            elif template is None:
                xpo[where][dwd_key]['template'] = template_gen.generate_template(name, arguments)
                xpo[where][dwd_key]['template_curation'] = 'auto'

    logger.info(f'Added {added} nodes.')
    of = open('updated_xpo_with_additions_please_rename.json', 'w')
    json.dump(xpo, of, indent=4)
    of.close()